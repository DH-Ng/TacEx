from typing import Literal

from isaaclab.sensors import SensorBaseCfg
from isaaclab.utils import configclass

from .gelsight_sensor import GelSightSensor
from .simulation_approaches.gelsight_simulator_cfg import GelSightSimulatorCfg

"""Configuration for a Gelsight tactile sensor."""


@configclass
class GelSightSensorCfg(SensorBaseCfg):
    class_type: type = GelSightSensor

    @configclass
    class Dimensions:
        """Dimensions here are in mm (we assume that the world units are meters)"""

        width: float = 0.0
        length: float = 0.0
        height: float = 0.0

    case_dimensions: Dimensions = Dimensions()
    gelpad_dimensions: Dimensions = Dimensions()

    @configclass
    class SensorCameraCfg:
        """Configs for the Camera of the GelSight sensor."""

        prim_path_appendix: str = "/Camera"
        update_period: float = 0
        resolution: tuple[int, int] = (32, 24)
        data_types: list[str] = ["depth"]
        clipping_range: tuple[float, float] = (0.0, 1.0)

    sensor_camera_cfg: SensorCameraCfg = SensorCameraCfg()

    data_types: list[str] = ["tactile_rgb", "marker_motion", "height_map", "camera_depth", "camera_rgb"]
    """Output of the GelSight Sensor

    - height_map: Generated by the sensor camera. Shape = the camera resolution specified in the SensorCameraCfg.
    - tactile_rgb: Tactile RGB image. Shape = tactile_img_resolution specified in the OpticalSimulator class.
    - marker_motion: Initial and current positions of the gelpad markers.
        Shape (num_envs, 2, num_markers_markers, 2)
        - dim = 1: initial, current markers
        - dim = 2: marker pos (x,y) in the image (x = width, y = height)
    - camera_depth: depth image from the sensor camera
    - camera_rgb: rgb image from the sensor camera
    """

    optical_sim_cfg: GelSightSimulatorCfg = None  # freely choose what simulation class, but can also be left None
    """Cfg class of the optical simulator you want to use."""

    marker_motion_sim_cfg: GelSightSimulatorCfg = None
    """Cfg class of the marker motion simulator you want to use."""

    compute_indentation_depth_class: Literal["optical_sim", "marker_motion_sim"] = "optical_sim"
    """Defines which approach is used for computing the indentation depth.

    You can use the method from your optical simulation (e.g. Taxim), or the one from your marker motion simulation (e.g. if its FEM based).
    """

    device: str = "cuda"
