
# import pymesh
#from meshpy.tet import MeshInfo, build, Options
from omni.physx.scripts import deformableUtils
from pxr import UsdPhysics, UsdGeom, Gf
from isaacsim.util.debug_draw import _debug_draw
draw = _debug_draw.acquire_debug_draw_interface()

from collections.abc import MutableMapping
import wildmeshing as wm

import random
import numpy as np
from numpy.linalg import norm

from isaaclab.utils import configclass

@configclass
class TetMeshCfg:
    """
    
    References: 

    """

    stop_quality: int = 10
    """
    Max AMIPS energy for stopping mesh optimization.

    Larger means less optimization and sooner stopping.
    """

    max_its: int = 80
    """
    Max number of mesh optimization iterations.
    """
    
    epsilon_r: float = 1e-2
    """ Relative envelope epsilon_r (definies the envelope size).

    -> Absolute epsilon = epsilon_r * diagonal_of_bbox.

    Smaller envelope pereserves features better.  
    Larger Envelope + larger edge_length = tetmesh with low res
    """

    edge_length_r: float = 1/2
    """ Relative target edge length l_r. 
    
    -> Absolute l = l_r * diagonal_of_bbox.

    Smaller edge length gives denser mesh.
    """
    
    skip_simplify: bool = False

    coarsen: bool = True

    log_level: int = 6
    """
    Log level, ranges from 0 to 6  (0 = most verbose, 6 = off).
    """

@configclass
class TriMeshCfg:
    """
    
    References: 

    """

    stop_quality: int = 10
    """
    Max AMIPS energy for stopping mesh optimization.

    Larger means less optimization and sooner stopping.
    """

    max_its: int = 80
    """
    Max number of mesh optimization iterations.
    """
    
    epsilon_r: float = 1e-2
    """ Relative envelope epsilon_r (definies the envelope size).
    -> Absolute epsilon = epsilon_r * diagonal_of_bbox.

    Smaller envelope pereserves features better.
    Larger Envelope + larger edge_length = tetmesh with low res
    """

    edge_length_r: float = 1/2
    """ Relative target edge length l_r. 
    -> Absolute l = l_r * diagonal_of_bbox.

    Smaller edge length gives denser mesh.
    """
    
    skip_simplify: bool = False

    coarsen: bool = True

    log_level: int = 6
    """
    Log level, ranges from 0 to 6  (0 = most verbose, 6 = off).
    """

class MeshGenerator():

    def __init__(self, config: dict | TetMeshCfg = None) -> None:
        if config is None:
            config = TetMeshCfg().to_dict()
            print("No config for tet computation provided, using default settings.")
        elif type(config) is TetMeshCfg:
            config = config.to_dict()
        self.cfg = config

        # tetgen = pymesh.tetgen()
        # tetgen.points = mesh.vertices # Input points.
        # tetgen.triangles = mesh.faces # Input triangles
        
        # # set tetgen settings
        # for k, v in config.items():
        #     try:
        #         getattr(tetgen, k)
        #     except AttributeError:
        #         raise ValueError("invalid option for tet generation: %s" % k)
        #     else:
        #         if v is not None:
        #             setattr(tetgen, k, v)

        # tetgen.run() # Execute tetgen
        # mesh = tetgen.mesh # Extract output tetrahedral mesh.
        # print("tet mesh information ")
        # print(mesh.num_vertices, mesh.num_faces, mesh.num_voxels)
        # tet_points = mesh.vertices
        # tet_indices = mesh.voxels
        
        #! Wildmeshing
        # reference: https://github.com/wildmeshing/wildmeshing-python/blob/master/wildmeshing/runners.py
        self.tetrahedralizer = wm.Tetrahedralizer(
            stop_quality=self.cfg["stop_quality"],     # Specify max AMIPS energy for stopping mesh optimization"
            max_its=self.cfg["max_its"],          # Max number of mesh optimization iterations
            epsilon=self.cfg["epsilon_r"],         # relative envelope epsilon_r. Absolute epsilon = epsilon_r * diagonal_of_bbox
            edge_length_r=self.cfg["edge_length_r"],   # Relative target edge length l_r. Absolute l = l_r * diagonal_of_bbox
            skip_simplify=self.cfg["skip_simplify"],
            coarsen=self.cfg["coarsen"],
        )
        self.tetrahedralizer.set_log_level(self.cfg["log_level"]) #Log level (0 = most verbose, 6 = off). 6 also means, that no tet data files are being generated by wildmeshing

    # def fix_mesh(self, mesh, detail="normal"):
    #     """
    #     Remesh the input mesh to remove degeneracies and improve triangle quality.

    #     Source: https://github.com/PyMesh/PyMesh/blob/main/scripts/fix_mesh.py
    #     Args:
    #         mesh (_type_): _description_
    #     """
    #     bbox_min, bbox_max = mesh.bbox
    #     diag_len = norm(bbox_max - bbox_min)
    #     print(f"diag_len = {diag_len}")
    #     if detail == "high":
    #         target_len = diag_len * 2.5e-3
    #     elif detail == "normal":
    #          target_len = diag_len * 5e-3 # adjusted values, cause we deal with very small objects, orig: 5e-3
    #     elif detail == "low":
    #         target_len = diag_len * 1e-2
    #     elif detail == "very low":
    #         target_len = diag_len * 5e-2

    #     print("Target resolution: {} mm".format(target_len))

    #     count = 0
    #     mesh, __ = pymesh.remove_duplicated_vertices(mesh, tol=target_len*1e-2)
    #     mesh, __ = pymesh.remove_degenerated_triangles(mesh, 100)
    #     #mesh, __ = pymesh.split_long_edges(mesh, target_len*2)
    #     num_vertices = mesh.num_vertices
    #     while True:
    #         mesh, __ = pymesh.collapse_short_edges(mesh, 1e-6, preserve_feature=True)
    #         mesh, __ = pymesh.collapse_short_edges(mesh, target_len,
    #                                                preserve_feature=True)
    #         mesh, __ = pymesh.remove_obtuse_triangles(mesh, 150.0, 100)
    #         if mesh.num_vertices == num_vertices:
    #             break

    #         num_vertices = mesh.num_vertices
    #         print(f"#v: {num_vertices}")
    #         count += 1
    #         if count > 10: break

    #     mesh = pymesh.resolve_self_intersection(mesh)
    #     mesh, __ = pymesh.remove_duplicated_faces(mesh)
    #     mesh = pymesh.compute_outer_hull(mesh)
    #     mesh, __ = pymesh.remove_duplicated_faces(mesh)
    #     mesh, __ = pymesh.remove_obtuse_triangles(mesh, 179.0, 5)
    #     mesh, __ = pymesh.remove_isolated_vertices(mesh)
        
    #     return mesh
    def generate_tet_mesh_for_prim(self, prim: UsdGeom.Mesh):
        # compute mesh
        points = np.array(prim.GetPointsAttr().Get())
        # triangles is a list of indices: every 3 consecutive indices form a triangle
        triangles = deformableUtils.triangulate_mesh(prim)

        #draw surface mesh
        # color = [(125,0,125,0.5)]
        # for i in range(0, len(triangles), 3):
        #     tet_points_idx = triangles[i:i+3]
        #     tet_points = [points[i] for i in tet_points_idx]
        #     draw.draw_points(tet_points, [(255,255,255,1)]*len(tet_points), [40]*len(tet_points)) 
        #     draw.draw_lines([tet_points[0]]*2, tet_points[1:], color*2, [10]*2) # draw from point 0 to every other point (3 times 0, cause line from 0 to the other 3 points)
        #     draw.draw_lines([tet_points[1]]*1, tet_points[2:], color*1, [10]*1)


        tet_mesh_points, tet_indices, surf_points, surf_indices = self.compute_tet_mesh(points, triangles)

        # update the usd mesh
        #self.update_surface_mesh(prim, surf_points=surf_points, triangles=surf_indices)
        
        # # draw the tet mesh
        # color = [(0,0,0,1)]
        # for i in range(0, len(tet_indices), 4):
        #     tet_points_idx = tet_indices[i:i+4]
        #     tet_points = [tet_mesh_points[i] for i in tet_points_idx]
        #     #draw.draw_points(tet_points, [(255,0,0,1)]*len(all_vertices), [10]*len(all_vertices)) 
        #     draw.draw_lines([tet_points[0]]*3, tet_points[1:], color*3, [10]*3) # draw from point 0 to every other point (3 times 0, cause line from 0 to the other 3 points)
        #     draw.draw_lines([tet_points[1]]*2, tet_points[2:], color*2, [10]*2)
        #     draw.draw_lines([tet_points[2]], [tet_points[3]], color, [10]) # draw line between the other 2 points


        return tet_mesh_points, tet_indices, surf_points, surf_indices
    
    def compute_tet_mesh(self, points, triangles):
        triangles = np.array(triangles, dtype=np.uint32).reshape(-1, 3)
        points = np.array(points, dtype=np.float64)

        #! Pymesh
        #mesh = pymesh.form_mesh(points, triangles)
        # print("input tri mesh")
        # print(f"#vertices {mesh.num_vertices}, #faces {mesh.num_faces}")

        # # # clean up tri mesh
        # # # mesh, info = pymesh.remove_duplicated_vertices(mesh, tol=0.00005)
        # # # mesh, info = pymesh.collapse_short_edges(mesh,  rel_threshold=0.1,  preserve_feature=True)
        # # # mesh, info = pymesh.remove_isolated_vertices(mesh)
        # # # mesh, info = pymesh.remove_degenerated_triangles(mesh, num_iterations=5)
        
        # #mesh = self.fix_mesh(mesh, detail="very low") # doesnt work well, idk why... Maybe input mesh is not good enough
        # # print("tri mesh after cleanup: ")
        # # print(f"#vertices {mesh.num_vertices}, #faces {mesh.num_faces}")

        # # from omni.isaac.debug_draw import _debug_draw
        # # draw = _debug_draw.acquire_debug_draw_interface()
        # # for t in range(0, len(triangles.flatten().tolist()), 3):
        # #     tri_points = points[t:t+3]
        # #     draw.draw_lines([tri_points[0]]*2, tri_points[1:], [(255,255,255,0.5)]*2, [10]*2) # draw from point 0 to every other point (3 times 0, cause line from 0 to the other 3 points)
        # #     draw.draw_lines([tri_points[1]], [tri_points[2]], [(255,255,255,0.5)], [10])  
        
        self.tetrahedralizer.set_mesh(points, triangles)
        self.tetrahedralizer.tetrahedralize()
        tet_points, tet_indices, _ = self.tetrahedralizer.get_tet_mesh(
            correct_surface_orientation=True,
            manifold_surface=True,
            # use_input_for_wn=True,
        )
        tet_indices = np.array(tet_indices).flatten().tolist()

        # surface
        surf_points, surf_indices = self.tetrahedralizer.get_tracked_surfaces()
        surf_points = surf_points[0] # surf_points is a list -> in case object consists of multiple surfaces
        surf_indices = np.array(surf_indices).flatten().tolist()
        return tet_points, tet_indices, surf_points, surf_indices
    
    @staticmethod
    def update_surface_mesh(prim: UsdGeom.Mesh, surf_points, triangles: list[int]):
        triangles = np.array(triangles).reshape(-1,3)

        prim.GetPointsAttr().Set(surf_points)
        prim.GetFaceVertexCountsAttr().Set([3] * triangles.shape[0]) # how many vertices each face has (3, cause triangles)
        prim.GetFaceVertexIndicesAttr().Set(triangles)
        prim.GetNormalsAttr().Set([]) # set to be empty, cause we use catmullClark and this gives us normals
        prim.SetNormalsInterpolation(UsdGeom.Tokens.faceVarying)
        # prim.GetSubdivisionSchemeAttr().Set("catmullClark") #none

        # set color with per face interpolation  
        colors = [(random.uniform(0.0, 0.75), random.uniform(0.0, 0.75), random.uniform(0.0, 0.75)) for _ in range(triangles.shape[0]*3)] 
        prim.CreateDisplayColorPrimvar(UsdGeom.Tokens.faceVarying).Set(colors) # num_surf_tri * 3
        
        # set uv_coor variable
        uv_coor = np.indices((int(triangles.shape[0]*1.5),2)).transpose((1,2,0)).reshape((-1,2))
        print("uv shape ", uv_coor.shape)
        # geom_mesh.GetSTAttr().Set(uv_coor)
        pv_api = UsdGeom.PrimvarsAPI(prim)
        pv = pv_api.GetPrimvar("primvars:st")
        pv.Set(uv_coor)
        pv.SetInterpolation(UsdGeom.Tokens.faceVarying)
        